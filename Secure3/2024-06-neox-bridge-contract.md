| Severity | Title |
| -------- | -------- | 
|L-01 |Solidity built-in ecrecover() is vulnerable to signature malleability attack, malicious validators can double the amount of valid signatures to meet threshold|

# [L-01] Solidity built-in ecrecover() is vulnerable to signature malleability attack, malicious validators can double the amount of valid signatures to meet threshold

## Location

https://github.com/Secure3Audit/code_NeoX_Bridge_Contract/blob/f3764f6770d85e9438997630adac73f5314afbf4/code/contracts/management/BridgeManagementImpl.sol#L46

## Description

`BridgeImplementationImpl.verifyValidatorSignatures()` utilizes Solidity built-in `ecrecover()` function for verfying validator signature. The problem is that `ecrecover()` does not protect the well-known signature malleability attack.

### Impact

Malicious validator can double the amount of valid signatures that they can provide.

For example, say there are 7 validators, threshold is 4, and 2 of the validators are malicious. Without this signature malleability bug, they can only provide 2 valid signatures for a deposit root, which does not meet threshold.

However, with this bug, each of the malicious validator can forge another valid signature, thus they will have 4 valid signatures, which meets the threshold.

With those 4 valid signatures, they can bypass the `management.verifyValidatorSignatures()` check and include a fake deposit root in the system, causing financial loss.

### Math behind ECDSA signature malleability attack

Given an ordered pair `(r, s)`, it is possible to forge a valid signature with the following formula:

```solidity
bytes32 s2 = bytes32(uint256(0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141) - uint256(s));
```

where `0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141` is the curve order for secp256k1: the underlying elliptic curve for ECDSA algorithm.

This attack is possible because ECDSA algorithm only verifies the x-coordinate of a random elliptic curve generated by the signer. That means y-coordinate is unchecked:

```solidity
z/s    *G + r/s    *P = (r,y)
z/(n-s)*G + r/(n-s)*P = (r, p-y)
z: 32-byte hash of the message that weâ€™re signing
s: (z+re)/k
G: generator point of secp256k1
r: x-coordinate of R = kG
P: public key (P = eG, e is private key)
y: y-coordinate of R = kG
n: curve_order (modulus of scalar field)
p: field_modulus (modulus of base field)
```

Since ECDSA algorithm only verifies if x-coordinate of R matches, we can find a symmetric elliptic curve point `(r, p-y)` to trick the verifier. The easiest way to do this is just to compute `n - s`.

For more info about the math behind this attack, check out [this article](https://www.derpturkey.com/inherent-malleability-of-ecdsa-signatures/).
