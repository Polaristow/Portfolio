| Severity | Title |
| -------- | -------- | 
|H-01 |Lack of effective slippage control for _gasSwapIn(Out)|
|H-02 |Attacker can "retrieveDeposit" then "redeemDeposit" with a future nonce to freeze the assets of subsequent depositers|
|H-03 |User can mint infinite amount of root hToken by bridging a mismatched pair of local and underlying token|
|H-04 |Attacker can retrySettlement by virtual account to steal accumulated fee in root bridge agent |
|H-05 |The premium is not taken into account when calculating execution gas cost  |
|H-06 | "retrySettlement" could be reentered by poisonous underlying token when clearing tokens |
|H-07 | Attacker can exploit "deposit" to drain Ulysess Liquidity Pool |
|H-08 | User can bypass bandwidth limit by repeatedly "balancing" the pool  |
|H-09 |sweep should transfer WETH instead of ETH|
|H-10 | Attacker can redeposit gas after "forceRevert()" to freeze all deposited gas budget of Root Bridge Agent |
|H-11 | Malicious user can set any contract as local hToken for an underlying since there is no access control for "_addLocalToken"  |
|H-12 |assetId of lastAsset is incorrectly updated in function removeAsset|
|H-13 |requiresFallbackGas cannot guarantee adequate gas for anyFallback|
|H-14 |Wrong AnycallFlag used in function _performCall of BranchBridgeAgent|
|M-01 |Missing deadline checks allow pending transactions to be maliciously executed|
|M-02 |User will permanently lose their assets if someone calls retryDeposit(Settlement) when redeemDeposit(Settlement) should be called|
|M-03 |depositGasAnycallConfig will fail due to unnecessary wrappedNativeToken.withdraw|
|M-04 |Incorrect parameter used for _unstakeToken() in function "restakeToken"|
|M-05 |User can "callOutSigned" without paying for gas by reentering "anyExecute" with virtual account |
|M-06 |Incorrect accounting logic for fallback gas will lead to insolvency |

## [H-01]  Lack of effective slippage control for _gasSwapIn(Out)

## Vulnerability details
### Impact
There is no effective slippage control for _gasSwapIn and _gasSwapOut. The current approach only ensures an abundant level of liquidity within the pool but does not provide protection against sandwich attacks.
### Proof of Concept
https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/RootBridgeAgent.sol#L659-L696
```
function _gasSwapIn(uint256 _amount, uint24 _fromChain) internal returns (uint256) {
    ......
    (bool zeroForOneOnInflow, uint24 priceImpactPercentage, address gasTokenGlobalAddress, address poolAddress) = 
        IPort(localPortAddress).getGasPoolInfo(_fromChain);
    (uint160 sqrtPriceX96,,,,,,) = IUniswapV3Pool(poolAddress).slot0();
    uint160 exactSqrtPriceImpact = (sqrtPriceX96 * (priceImpactPercentage / 2)) / GLOBAL_DIVISIONER;
    uint160 sqrtPriceLimitX96 =
        zeroForOneOnInflow ? sqrtPriceX96 - exactSqrtPriceImpact : sqrtPriceX96 + exactSqrtPriceImpact;

    //Swap imbalanced token as long as we haven't used the entire amountSpecified and haven't reached the price limit
    try IUniswapV3Pool(poolAddress).swap(
        address(this),
        zeroForOneOnInflow,
        int256(_amount),
        sqrtPriceLimitX96,
        abi.encode(SwapCallbackData({tokenIn: gasTokenGlobalAddress}))
    ) returns (int256 amount0, int256 amount1) {
        return uint256(zeroForOneOnInflow ? amount1 : amount0);
    } catch (bytes memory) {
        _forceRevert();
        return 0;
    }
}
```
The sqrtPriceLimitX96 cannot effectively control slippage, as it still relies on sqrtPriceX96, which can be manipulated through sandwich attacks. As long as there is sufficient liquidity within the pool, the price impact will not be excessive, enabling the sandwich attack to suceed.


## [H-02]  Attacker can "retrieveDeposit" then "redeemDeposit" with a future nonce to freeze the assets of subsequent depositers

## Vulnerability details
### Impact
Attacker can call retrieveDeposit with a future deposit nonce and anyFallback will be triggered to set the deposit status to Failed. Then, the attacker calls redeemDeposit to delete getDeposit[_depositNonce]. When a unlucky depositer makes a deposit with that nonce, everything will go as usual on branch chain, except that executionHistory[fromChainId][nonce] has already been marked as true on root chain. As a result, the root chain transaction will forcerevert() and the depositer has no way to get their assets back.
### Proof of Concept
https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/RootBridgeAgent.sol#L1140-L1156

```
function retrieveDeposit(uint32 _depositNonce) external payable lock requiresFallbackGas {
    //Encode Data for cross-chain call.
    bytes memory packedData = abi.encodePacked(bytes1(0x08), _depositNonce, msg.value.toUint128(), uint128(0));

    //Update State and Perform Call
    _sendRetrieveOrRetry(packedData);
}

function anyExecute(bytes calldata data)
    external
    virtual
    requiresExecutor
    returns (bool success, bytes memory result)
{
    ......
        /// DEPOSIT FLAG: 8 (retrieveDeposit)
    } else if (flag == 0x08) {
        //Get nonce
        uint32 nonce = uint32(bytes4(data[1:5]));

        //Check if tx has already been executed
        if (!executionHistory[fromChainId][uint32(bytes4(data[1:5]))]) {
            //Toggle Nonce as executed
            executionHistory[fromChainId][nonce] = true;

            //Retry failed fallback
            (success, result) = (false, "");
        } else {
            _forceRevert();
            //Return true to avoid triggering anyFallback in case of `_forceRevert()` failure
            return (true, "already executed tx");
        }
    }
    ......
}

function _redeemDeposit(uint32 _depositNonce) internal {
    Deposit storage deposit = getDeposit[_depositNonce];

    // will be skipped since length is zero
    for (uint256 i = 0; i < deposit.hTokens.length;) {
        _clearToken(deposit.owner, deposit.hTokens[i], deposit.tokens[i], deposit.amounts[i], deposit.deposits[i]);

        unchecked {
            ++i;
        }
    }

    //Delete Failed Deposit Token Info
    delete getDeposit[_depositNonce];
}
```

## Recommended Mitigation Steps

Add a check in retrieveDeposit:
```
require(getDeposit[_depositNonce].owner == msg.sender);
```
## [H-03]  User can mint infinite amount of root hToken by bridging a mismatched pair of local and underlying token

## Vulnerability details
### Impact
Users can bridge a mismatched pair of local hToken and underlying Token from branch chain to root chain, thereby infinitely minting any root hToken.

### Proof of Concept
https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/RootBridgeAgent.sol#L50-L64

Below is the flow when a user bridges asset from branch chain to root chain:

```
    function bridgeOut(address _depositor, address _localAddress, address _underlyingAddress, uint256 _amount, uint256 _deposit) external virtual requiresBridgeAgent {
        if (_amount - _deposit > 0) {
            _localAddress.safeTransferFrom(_depositor, address(this), _amount - _deposit);
            ERC20hTokenBranch(_localAddress).burn(_amount - _deposit);
        }
        if (_deposit > 0) {
            _underlyingAddress.safeTransferFrom(
                _depositor, address(this), _denormalizeDecimals(_deposit, ERC20(_underlyingAddress).decimals())
            );
        }
    }
```
```
    function bridgeIn(address _recipient, DepositParams memory _dParams, uint24 _fromChain) public requiresAgentExecutor
    {
        //Check Deposit info from Cross Chain Parameters.
        if (!CheckParamsLib.checkParams(localPortAddress, _dParams, _fromChain)) {
            revert InvalidInputParams();
        }

        //Get global address
        address globalAddress = IPort(localPortAddress).getGlobalTokenFromLocal(_dParams.hToken, _fromChain);

        //Check if valid asset
        if (globalAddress == address(0)) revert InvalidInputParams();

        //Move hTokens from Branch to Root + Mint Sufficient hTokens to match new port deposit
        IPort(localPortAddress).bridgeToRoot(_recipient, globalAddress, _dParams.amount, _dParams.deposit, _fromChain);
    }
```
```
function checkParams(address _localPortAddress, DepositParams memory _dParams, uint24 _fromChain)
        internal
        view
        returns (bool)
    {
        if (
            (_dParams.amount < _dParams.deposit) //Deposit can't be greater than amount.
                || (_dParams.amount > 0 && !IPort(_localPortAddress).isLocalToken(_dParams.hToken, _fromChain)) //Check local exists.
                || (_dParams.deposit > 0 && !IPort(_localPortAddress).isUnderlyingToken(_dParams.token, _fromChain)) //Check underlying exists.
        ) {
            return false;
        }
        return true;
    }
```
```
    function bridgeToRoot(address _recipient, address _hToken, uint256 _amount, uint256 _deposit, uint24 _fromChainId) external requiresBridgeAgent
    {
        if (!isGlobalAddress[_hToken]) revert UnrecognizedToken();

        if (_amount - _deposit > 0) _hToken.safeTransfer(_recipient, _amount - _deposit);
        if (_deposit > 0) mint(_recipient, _hToken, _deposit, _fromChainId);
    }
```
During the whole process, only _dParams.hToken is LocalToken and _dParams.token is UnderlyingToken are checked. However, no check is performed to ensure that _dParams.hToken corresponds to _dParams.token, which means user can use an arbitary underlying token as input and receive a diffrent (more valuable) hToken. Below are the steps that Alice receives arb-hETH by depositing LIN, a token created by herself:

1. Alice creates a new ERC20 token "LIN" on BNB Chain and mints herself max(uint256)
2. Alice addLocalToken for LIN at CoreBranchRouter
3. Alice callOutAndBridge with _dParams = {hToken: bnb-hETH, Token: LIN, amount: 10e10, deposit: 10e10}
4. bridgeOut at BranchPort charges Alice 10e10 LIN
5. checkParams at root chain passes
6. bridgeToRoot at RootPort mints Alice 10e10 arb-hETH
## Recommended Mitigation Steps
Add a check to ensure that local token and underlying token match:
```
function checkParams(address _localPortAddress, DepositParams memory _dParams, uint24 _fromChain)
        internal
        view
        returns (bool)
    {
        if (
            (_dParams.amount < _dParams.deposit) //Deposit can't be greater than amount.
                || (_dParams.amount > 0 && !IPort(_localPortAddress).isLocalToken(_dParams.hToken, _fromChain)) //Check local exists.
                || (_dParams.deposit > 0 && IPort(_localPortAddress).getLocalTokenFromUnder(_dParams.token, _fromChain) != _dParams.hToken //Check underlying exists and matches.
        ) {
            return false;
        }
        return true;
    }
```



## [H-04]  Attacker can retrySettlement by virtual account to steal accumulated fee in root bridge agent 

## Vulnerability details
### Impact
Excess gas fee is accumulated within root bridge agent as WETH. Attacker can retrySettlement by virtual account to steal the accumulated fee.
### Proof of Concept
https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/RootBridgeAgent.sol#L759
```
function retrySettlement(uint32 _settlementNonce, uint128 _remoteExecutionGas) external payable {
    //Update User Gas available.
    if (initialGas == 0) {
        userFeeInfo.depositedGas = uint128(msg.value);
        userFeeInfo.gasToBridgeOut = _remoteExecutionGas;
    }
    //Clear Settlement with updated gas.
    _retrySettlement(_settlementNonce);
}

function _retrySettlement(uint32 _settlementNonce) internal returns (bool) {
    Settlement memory settlement = getSettlement[_settlementNonce];
    if (settlement.owner == address(0)) return false;

    bytes memory newGas = abi.encodePacked(_manageGasOut(settlement.toChain));
    for (uint256 i = 0; i < newGas.length;) {
        settlement.callData[settlement.callData.length - 16 + i] = newGas[i];
        unchecked {
            ++i;
        }
    }
    ......
    _performCall(settlement.callData, settlement.toChain);

    return true;
}

function _manageGasOut(uint24 _toChain) internal returns (uint128) {
    uint256 amountOut;
    address gasToken;
    uint256 _initialGas = initialGas;
    ......
    if (_initialGas > 0) {
        if (userFeeInfo.gasToBridgeOut <= MIN_FALLBACK_RESERVE * tx.gasprice) revert InsufficientGasForFees();
        (amountOut, gasToken) = _gasSwapOut(userFeeInfo.gasToBridgeOut, _toChain);
    } else {
        if (msg.value <= MIN_FALLBACK_RESERVE * tx.gasprice) revert InsufficientGasForFees();
        wrappedNativeToken.deposit{value: msg.value}();
        (amountOut, gasToken) = _gasSwapOut(msg.value, _toChain);
    }

    IPort(localPortAddress).burn(address(this), gasToken, amountOut, _toChain);
    return amountOut.toUint128();
}
```
Steps:

1. Prepare some failed settlements by callOutSigned with zero _remoteExecutionGas and non-arb toChain.
2. callOutSigned with nonzero _remoteExecutionGas.
3. Virtual account calls retrySettlement with a failed nonce.
initialGas will be greater than zero and userFeeInfo.gasToBridgeOut amount of WETH will be swapped into remote chain gas token.
4. Receive remaining gas token when _payExecutionGas at branch chain.
5. Virtual account repeats 3 until accumulated WETH is drained.
Note: It's better to attack with a larger _remoteExecutionGas so that less gas will be wasted by multiple executions.
```
function _gasSwapIn(bytes memory gasData) internal virtual returns (uint256 gasAmount) {
    //Cast to uint256
    gasAmount = uint256(uint128(bytes16(gasData)));
    //Move Gas hTokens from Branch to Root / Mint Sufficient hTokens to match new port deposit
    IPort(localPortAddress).withdraw(address(this), address(wrappedNativeToken), gasAmount);
}

function _payExecutionGas(address _recipient, uint256 _initialGas) internal virtual {
    uint256 gasRemaining = wrappedNativeToken.balanceOf(address(this));
    wrappedNativeToken.withdraw(gasRemaining);
    ......
    _replenishGas(minExecCost);
    SafeTransferLib.safeTransferETH(_recipient, gasRemaining - minExecCost);
    ......
}
```

## Recommended Mitigation Steps
1. Store availableGas at the beginning of anyExecute:
```
uint256 availableGas = userFeeInfo.depositedGas - userFeeInfo.gasToBridgeOut;
```
2. Delete userFeeInfo.gasToBridgeOut after _manageGasOut.
3. Use availableGas as input for _payExecutionGas.


## [H-05]  The premium is not taken into account when calculating execution gas cost 

## Vulnerability details
### Impact
The premium is not taken into account when calculating minExecCost in _payExecutionGas. Transaction may cosume more gas than what has been replenished.
### Proof of Concept
https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/RootBridgeAgent.sol#L811
https://github.com/anyswap/multichain-smart-contracts/blob/645d0053d22ed63005b9414b5610879094932304/contracts/anycall/v7/AnycallV7Config.sol#L204
```
function _payExecutionGas(uint128 _depositedGas, uint128 _gasToBridgeOut, uint256 _initialGas, uint24 _fromChain) internal {
    ......
    uint256 minExecCost = tx.gasprice * (MIN_EXECUTION_OVERHEAD + _initialGas - gasleft());
    if (minExecCost > availableGas) {
        _forceRevert();
        return;
    }
    _replenishGas(minExecCost);
    ......
}
```
The gas price is determined as tx.gasprice in _payExecutionGas, but the actual charge is tx.gasprice + _feeData.premium. A malicious user can consume an arbitrarily large amount of gas by making external calls at virtual account to generate shortfall. By repeating so, the gas budget of bridge agent will be depleted, and the entire system will become inoperable.
```
function chargeFeeOnDestChain(address _from, uint256 _prevGasLeft) external onlyAnycallContract {
    if (!_isSet(mode, FREE_MODE)) {
        uint256 gasUsed = _prevGasLeft + EXECUTION_OVERHEAD - gasleft();
        uint256 totalCost = gasUsed * (tx.gasprice + _feeData.premium);
        uint256 budget = executionBudget[_from];
        require(budget > totalCost, "no enough budget");
        executionBudget[_from] = budget - totalCost;
        _feeData.accruedFees += uint128(totalCost);
    }
}
```
## Recommended Mitigation Steps
Replace tx.gasprice by tx.gasprice + premium

## [H-06]  "retrySettlement" could be reentered by poisonous underlying token when clearing tokens

## Vulnerability details
### Impact
When clearing tokens, _underlyingAddress.safeTransfer is called; however, the lock is missing on retrySettlement, making reentrancy possible.

### Proof of Concept
All essential entry points of ulysses omnichain are modified with lock to prevent reentrancy. However, the lock is missing on retrySettlement at RootBridgeAgent.
```
function retrySettlement(uint32 _settlementNonce, uint128 _remoteExecutionGas) external payable {
    //Update User Gas available.
    if (initialGas == 0) {
        userFeeInfo.depositedGas = uint128(msg.value);
        userFeeInfo.gasToBridgeOut = _remoteExecutionGas;
    }
    //Clear Settlement with updated gas.
    _retrySettlement(_settlementNonce);
}
```
When clearing tokens, an external call to _underlyingAddress is made. However, _underlyingAddress may be an arbitary contract since token is permissionlessly added, which means it could reenter retrySettlement to receive token multiple times.
```
function withdraw(address _recipient, address _underlyingAddress, uint256 _deposit)
    external
    override(IBranchPort, BranchPort)
    requiresBridgeAgent
{
    _underlyingAddress.safeTransfer(
        _recipient, _denormalizeDecimals(_deposit, ERC20(_underlyingAddress).decimals())
    );
}
```
Below are the steps of the attack, starting with 1 BNB on BNB Chain:

1. Create a contract "XIN" on Arbitrum (the root chain).
```
contract XIN {
    string public name = "xiaoxin";
    string public symbol = "XIN";
    uint8 public decimals = 18;

    address private _virtualAccount;
    RootBridgeAgent private _rootBridgeAgent;

    uint256 private countdown = 0;
    uint256 private nonce = 0;

    constructor(address virtualAccount, address rootBridgeAgent) {
        _virtualAccount = virtualAccount;
        _rootBridgeAgent = RootBridgeAgent(rootBridgeAgent);
    }

    function transfer(address, uint256) external {
        if (countdown == 0) {return;}
        else {
            _rootBridgeAgent.retrySettlement(nonce, 0);
            --countdown;
        }
    }

    function initiate() external {
        require(msg.sender == _virtualAccount);
        countdown = 100;
        nonce = _rootBridgeAgent.settlementNonce();
    }
}
```
2. addLocalToken for XIN at ArbitrumCoreBranchRouter.
3. callOutSignedAndBridge (on Arbitrum) with _dParams = {hToken: arb-hXIN, token: XIN, amount: 1, deposit: 1} and receive 1 arb-hXIN at virtual account.
4. callOutSignedAndBridge (on BNB Chain) with _dParams = {hToken: bnb-hBNB, token: BNB, amount: 1, deposit: 1} and receive 1 arb-hBNB at virtual account.
5. callOut with params = abi.encode(0x03, [{target: XIN, calldata: abi.encode(selector("initiate()")}], {recipient: attacker, outputTokens: [arb-hXIN, arb-hBNB], amountsOut: [1, 1], depositsOut: [1, 0]}, Arb), initiate() will be called by the virtual account to change safeTransfer into reentrancy mode.
6. retrySettlement is reentered 100 times and attacker receives 101 arb-hBNB.
## Recommended Mitigation Steps
Add lock for retrySettlement.

## [H-07]  Attacker can exploit "deposit" to drain Ulysess Liquidity Pool 

## Vulnerability details
### Impact
Users have two methods to add liquidity to the Ulysses Pool: "mint" and "deposit". However, the latter may return an inaccurate output, which could be exploited to drain the pool.
### Proof of Concept
https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-amm/UlyssesPool.sol#L942-L1019
In the process to mint amount of share, the state change is A:(band, supply×weight) -> B:(band+update, (supply+amount)×weight). User pays amount-sum(posFee)+sum(negFee) of underlying to acquire amount of share. This approach is precise.

In the process to deposit amount of underlying, the simulated state change is A:(band, supply×weight) -> B:(band+update, (supply+amount)×weight). Then (posFee, negFee) is derived from the simulation of A->B. The actual state change is A:(band, supply×weight) -> B':(band+update+posFee, (supply+amount+sum(posFee)-sum(negFee))×weight). We denote the actual fee of A->B' as (posFee', negFee'). User pays amount of underlying to acquire amount+sum(posFee)-sum(negFee) of share. This approach would be acceptable if sum(pos')-sum(neg') >= sum(pos), but this inequality doesn't always hold. If sum(pos')-sum(neg') < sum(pos), insolvency occurs; if sum(pos')-sum(neg') < sum(pos)-sum(neg), user could take profit.

An example is given below:
```
amount = 10000000
supply = 1000000000000000013287555072
weight = [1, 59, 47]
band = [99452334745147595191585509, 4253569467850027815346666, 216725069177793291903286517]
```
When Alice deposits 10000000 underlying, she will get 36215776 share. However, the pool actually worsens.
```
oldRebalancingFee = [0, 10519971631761767037843097, 18152377668510835770992]
newRebalancingFee = [0, 10519971631761767000804564, 18152377668510882599904]
oldMinusNew = [0, +37038533, -46828912]
```
Actually there should be a systemic approach to construct states of sum(pos')-sum(neg') < sum(pos)-sum(neg) for attacks. However, due to limited time, I have only conducted random tests. By continuously searching for profitable states and modifying the pool state accordingly, attackers can eventually drain the pool.
```
FAQ
Here are several questions that readers may have:

Q: Why there are three diffrent scenarios? Why could insolvency and user loss happen simultaneously?
A: Imagine when you deposit 100$ to a bank, the bank increases your balance by 80$ and claims itself has got 120$.

Q: Why can sum(pos')-sum(neg') >= sum(pos) not hold?
A: Difficult question! Roughly this could happen when amount is significantly smaller than supply and posFee is excessively large.

Q: How can the pool be modified to a target state?
A: There are several methods including "mint", "redeem" and "swap", but the "deposit" method should not be used until we reach the target state because attacker will mostly experience losses from that.

Q: Why can the attacker eventually drain the pool?
A：When "mint", "redeem" or "swap", the attacker pays exactly the delta value of _calculateRebalancingFee. However, when making a "deposit", the attacker receives more than what they deserve. At last, by adding liquidity, _calculateRebalancingFee can be reduced, so the pool will be drained.

Q: Why don't you provide a coded POC of attack?
A: We know "deposit" is dangerous and we deprecate it, that's enough.
```

## FAQ
Here are several questions that readers may have:

Q: Why there are three diffrent scenarios? Why could insolvency and user loss happen simultaneously?
A: Imagine when you deposit 100$ to a bank, the bank increases your balance by 80$ and claims itself has got 120$.

Q: Why can sum(pos')-sum(neg') >= sum(pos) not hold?
A: Difficult question! Roughly this could happen when amount is significantly smaller than supply and posFee is excessively large.

Q: How can the pool be modified to a target state?
A: There are several methods including "mint", "redeem" and "swap", but the "deposit" method should not be used until we reach the target state because attacker will mostly experience losses from that.

Q: Why can the attacker eventually drain the pool?
A：When "mint", "redeem" or "swap", the attacker pays exactly the delta value of _calculateRebalancingFee. However, when making a "deposit", the attacker receives more than what they deserve. At last, by adding liquidity, _calculateRebalancingFee can be reduced, so the pool will be drained.

Q: Why don't you provide a coded POC of attack?
A: We know "deposit" is dangerous and we deprecate it, that's enough.
## Recommended Mitigation Steps
Deprecate the "deposit" method. It is hard to find a correct way to handle this.

## [H-08]  User can bypass bandwidth limit by repeatedly "balancing" the pool 

## Vulnerability details
### Impact
The goal with bandwidths is to have a maximum that can be withdrawn (swapped) from a pool, so in case a specific chain (or token from a chain) is exploited, then it only can partially affect these pools. However, the maximum limit can be bypassed by repeatedly "balancing" the pool to increase bandwidth for the exploited chain.

Introducing "Balancing": A Technique for Redistributing Bandwidth
During ulyssesAddLP or ulyssesAddLP, liquidity is first distributed or taken proportionally to diff (if any exists), then distributed or taken proportionally to weight. Suppose integer t is far smaller than diff (since the action itself can also change diff), after repeatedly adding t LP, removing t lp, adding t LP, removing t Lp ...... the pool will finally reach another stable state where the ratio of diff to weight is a constant among destinations. This implies that the currentBandwidth will be proportional to weight.

### Proof of Concept
https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-amm/UlyssesPool.sol#L539-L671
Suppose Avalanche is down. Unluckily, Alice holds 100 ava-hETH. She wants to swap ava-hETH for bnb-hETH.

Let's take a look at bnb-hETH pool. Suppose weights are mainnet:4, Avalanche:3, Linea:2. Total supply is 90. Target bandwidths are mainnet:40, Avalanche:30, Linea:20. Current bandwidths are mainnet:30, Avalanche:2(few left), Linea:22.

Ideally Alice should only be able to swap for 2 bnb-hETH. However, she swaps for 0.1 bnb-hETH first. Then she uses the 0.1 bnb-hETH to "balance" the pool (as mentioned above). Current bandwidths will become mainnet:24, Avalanche:18, Linea:12. Then Alice swaps for 14 bnb-hETH and "balance" the pool again. By repeating the process, she can acquire nearly all of the available liquidity in pool and LP loss will be unbounded.
## Recommended Mitigation Steps
1. During ulyssesAddLP or ulyssesAddLP, always distribute or take liquidity proportionally to weight.
2. When swapping A for B, reduce bandwidth of A in B pool (as is currently done) while add bandwidth of B in A pool (instead of distributing them among all bandwidths).

## [H-09]  sweep should transfer WETH instead of ETH

## Vulnerability details
### Impact
Excess gas are accumulated as WETH. However, sweep transfers ETH.
### Proof of Concept
https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/RootBridgeAgent.sol#L1263

```
function sweep() external {
    if (msg.sender != daoAddress) revert NotDao();
    uint256 _accumulatedFees = accumulatedFees - 1;
    accumulatedFees = 1;
    SafeTransferLib.safeTransferETH(daoAddress, _accumulatedFees);
}
```
As below, the contract receive WETH at _gasSwapIn. Then, WETH is partially unwrapped at _replenishGas. Excess gas are stored as WETH.
```
function _gasSwapIn(uint256 _amount, uint24 _fromChain) internal returns (uint256) {
    //Get fromChain's Gas Pool Info
    (bool zeroForOneOnInflow, uint24 priceImpactPercentage, address gasTokenGlobalAddress, address poolAddress) =
        IPort(localPortAddress).getGasPoolInfo(_fromChain);
    ......
    //Swap imbalanced token as long as we haven't used the entire amountSpecified and haven't reached the price limit
    try IUniswapV3Pool(poolAddress).swap(
        address(this),
        zeroForOneOnInflow,
        int256(_amount),
        sqrtPriceLimitX96,
        abi.encode(SwapCallbackData({tokenIn: gasTokenGlobalAddress}))
    ) returns (int256 amount0, int256 amount1) {
        return uint256(zeroForOneOnInflow ? amount1 : amount0);
    } catch (bytes memory) {
        _forceRevert();
        return 0;
    }
}

function _payExecutionGas(uint128 _depositedGas, uint128 _gasToBridgeOut, uint256 _initialGas, uint24 _fromChain) internal {
    ......
    //Replenish Gas
    _replenishGas(minExecCost);

    //Account for excess gas
    accumulatedFees += availableGas - minExecCost;
}

function _replenishGas(uint256 _executionGasSpent) internal {
    //Unwrap Gas
    wrappedNativeToken.withdraw(_executionGasSpent);
    IAnycallConfig(IAnycallProxy(localAnyCallAddress).config()).deposit{value: _executionGasSpent}(address(this));
}
```
## Recommended Mitigation Steps
Transfer WETH in sweep.

## [H-10]  Attacker can redeposit gas after "forceRevert()" to freeze all deposited gas budget of Root Bridge Agent

## Vulnerability details
### Impact
forceRevert() withdraws all deposited gas budget of Root Bridge Agent to ensure that failed AnyCall execution will not be charged. However, if forceRevert() took place during a call made by virtual account, gas can be replenished later manually. As a result, the AnyCall execution will succeed but all withdrawn gas will be frozen.
### Proof of Concept
https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/RootBridgeAgent.sol#L1233-L1241

```
function anyExecute(bytes calldata data)
    external
    virtual
    requiresExecutor
    returns (bool success, bytes memory result)
{
    uint256 _initialGas = gasleft();
    uint24 fromChainId;
    UserFeeInfo memory _userFeeInfo;

    if (localAnyCallExecutorAddress == msg.sender) {
        initialGas = _initialGas;
        (, uint256 _fromChainId) = _getContext();
        fromChainId = _fromChainId.toUint24();

        _userFeeInfo.depositedGas = _gasSwapIn(
            uint256(uint128(bytes16(data[data.length - PARAMS_GAS_IN:data.length - PARAMS_GAS_OUT]))), fromChainId).toUint128();
        _userFeeInfo.gasToBridgeOut = uint128(bytes16(data[data.length - PARAMS_GAS_OUT:data.length]));
    } else {
        fromChainId = localChainId;
        _userFeeInfo.depositedGas = uint128(bytes16(data[data.length - 32:data.length - 16]));
        _userFeeInfo.gasToBridgeOut = _userFeeInfo.depositedGas;
    }

    if (_userFeeInfo.depositedGas < _userFeeInfo.gasToBridgeOut) {
        _forceRevert();
        return (true, "Not enough gas to bridge out");
    }

    userFeeInfo = _userFeeInfo;

    // execution part
    ............

    if (initialGas > 0) {
        _payExecutionGas(userFeeInfo.depositedGas, userFeeInfo.gasToBridgeOut, _initialGas, fromChainId);
    }
}
```
To implement the attack, attacker callOutSigned on a branch chain to bypass lock. On the root chain, virtual account makes three external calls.
1. retryDeposit at Arbitrum Branch Bridge Agent with an already executed nonce. The call will forceRevert() and initialGas will be nonzero since it has not been modified by reentering. As a result, all execution gas budget will be withdrawn.
```
function _forceRevert() internal {
    if (initialGas == 0) revert GasErrorOrRepeatedTx();

    IAnycallConfig anycallConfig = IAnycallConfig(IAnycallProxy(localAnyCallAddress).config());
    uint256 executionBudget = anycallConfig.executionBudget(address(this));

    // Withdraw all execution gas budget from anycall for tx to revert with "no enough budget"
    if (executionBudget > 0) try anycallConfig.withdraw(executionBudget) {} catch {}
}
```
2. callOut at Arbitrum Branch Bridge Agent. The call should succeed and initialGas is deleted.
```
callOut at Arbitrum Branch Bridge Agent. The call should succeed and initialGas is deleted.
```
3. Directly deposit a small amount of gas at Anycall Config to ensure the success of the transaction.
```
function deposit(address _account) external payable {
    executionBudget[_account] += msg.value;
    emit Deposit(_account, msg.value);
}
```
Then, the original call proceeds and _payExecutionGas will be skipped. The call will succeed, with all withdrawn gas budget permanently frozen. (In current implementation, ETH can be sweeped to dao address, but this is another mistake, sweep should transfer WETH instead.)
## Recommended Mitigation Steps
Add a msg.sender check in _forceRevert to ensure local call will be directly reverted.

## [H-11]  Malicious user can set any contract as local hToken for an underlying since there is no access control for "_addLocalToken"

## Vulnerability details
### Impact
Malicious user can deliberately set a irrelevant (or even poisonous) local hToken for an underlying token, as anyone can directly access _addLocalToken at root chain without calling addLocalToken at branch chain first.
### Proof of Concept
https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/CoreBranchRouter.sol#L78
```function addLocalToken(address _underlyingAddress) external payable virtual {
    //Get Token Info
    string memory name = ERC20(_underlyingAddress).name();
    string memory symbol = ERC20(_underlyingAddress).symbol();

    //Create Token
    ERC20hToken newToken = ITokenFactory(hTokenFactoryAddress).createToken(name, symbol);

    //Encode Data
    bytes memory data = abi.encode(_underlyingAddress, newToken, name, symbol);

    //Pack FuncId
    bytes memory packedData = abi.encodePacked(bytes1(0x02), data);

    //Send Cross-Chain request (System Response/Request)
    IBridgeAgent(localBridgeAgentAddress).performCallOut{value: msg.value}(msg.sender, packedData, 0, 0);
}
```
The intended method to add a new local token for an underlying is by calling function addLocalToken at the branch chain. However, it appears that the last line of code, IBridgeAgent(localBridgeAgentAddress).performCallOut{value: msg.value}(msg.sender, packedData, 0, 0); uses performCallOut instead of performSystemCallOut. This means that users can directly callOut at branch bridge agent with _params = abi.encodePacked(bytes1(0x02), abi.encode(_underlyingAddress, anyContract, name, symbol)) to invoke _addLocalToken at the root chain without calling addLocalToken first. As a result, they may set an arbitrary contract as the local token. It's worth noting that the impact is irreversible as there is no mechanism to modify or delete local tokens, meaning that the underlying token can never be properly bridged in the future.

The branch hToken is called by function bridgeIn when redeemDeposit or clearToken:
```
function bridgeIn(address _recipient, address _localAddress, uint256 _amount)
    external
    virtual
    requiresBridgeAgent
{
    ERC20hTokenBranch(_localAddress).mint(_recipient, _amount);
}
```
Below are several potetial exploiting methods:

1. If a regular ERC20 contract with admin minting permissions is set, exploiter can mint unlimited amount of local token for himself. By bridging them, he can receive an arbitrary amount of global token at the root chain.
2. If an unrelated contract with empty mint function is set, the underlying asset would be unable to be bridged in from the root chain, and users who attempt to do so could lose their assets.
3. If a malicious contract is set, gas griefing is possible.
4. This contract may serve as an intermediary for reentrancy. (I haven't found a concrete way so far but there is a potential risk)
## Recommended Mitigation Steps
Use performSystemCallOut and executeSystemRequest to send Cross-Chain request for adding local token.


## [H-12]  assetId of lastAsset is incorrectly updated in function removeAsset 

## Vulnerability details
### Impact
assetId of lastAsset is incorrectly updated in function removeAsset, leading to data coruption.
### Proof of Concept
https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-amm/UlyssesToken.sol#L72
```
function removeAsset(address asset) external nonReentrant onlyOwner {
    // No need to check if index is 0, it will underflow and revert if it is 0
    uint256 assetIndex = assetId[asset] - 1;

    uint256 newAssetsLength = assets.length - 1;

    if (newAssetsLength == 0) revert CannotRemoveLastAsset();

    totalWeights -= weights[assetIndex];

    address lastAsset = assets[newAssetsLength];

    // Id should be index + 1
    assetId[lastAsset] = assetIndex;

    assets[assetIndex] = lastAsset;
    weights[assetIndex] = weights[newAssetsLength];

    assets.pop();
    weights.pop();
    assetId[asset] = 0;

    emit AssetRemoved(asset);

    updateAssetBalances();

    asset.safeTransfer(msg.sender, asset.balanceOf(address(this)));
}
```
When removing an asset, the algorithm moves the last asset to the position of the asset to be removed. However, the Id of the last asset is updated as assetId[lastAsset] = assetIndex; breaking the relationship id = index + 1. In future operations, unexpected outcomes may occur due to this error.


## Recommended Mitigation Steps
```
assetId[lastAsset] = assetIndex + 1;
```

## [H-13]  requiresFallbackGas cannot guarantee adequate gas for anyFallback

## Vulnerability details
### Impact
requiresFallbackGas cannot guarantee adequate gas for anyFallback. If fallback execution _forceRevert(), the user can no longer redeemDeposit and their asset will be permanently lost.


### Proof of Concept
https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/BranchBridgeAgent.sol#L1061-L1072
https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/BranchBridgeAgent.sol#L1410-L1412
```
requiresFallbackGas cannot guarantee adequate gas for anyFallback. If fallback execution _forceRevert(), the user can no longer redeemDeposit and their asset will be permanently lost.


```
There are two possibilities that deposited gas would be insufficient for fallback execution:

1. msg.value is only slightly larger than tx.gasprice * MIN_FALLBACK_RESERVE but smaller than tx.gasprice * (MIN_FALLBACK_RESERVE + _initialGas - gasLeft)
2. tx.gasprice rises during two transactions.
## Recommended Mitigation Steps
Charge and replenish fallback gas during the initial deposit call and never forceRevert() fallback execution (consequence is severe).

## [H-14]  Wrong AnycallFlag used in function _performCall of BranchBridgeAgent

## Vulnerability details
### Impact
Wrong AnycallFlag FLAG_ALLOW_FALLBACK is used in _performCall of BranchBridgeAgent. Gas are credited locally instead of remotely, despite gas has already been deposited to bridge out.
### Proof of Concept
https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/BranchBridgeAgent.sol#L1006-L1011
```
function _performCall(bytes memory _calldata) internal virtual {
    //Sends message to AnycallProxy
    IAnycallProxy(localAnyCallAddress).anyCall(
        rootBridgeAgentAddress, _calldata, rootChainId, AnycallFlags.FLAG_ALLOW_FALLBACK, ""
    );
}
```
According to the doc, Execution gas fees are credited to the recipient contract (Bridge Agent) deducting the gas spent from this contract's executionBudget kept in the AnycallConfig contract.
## Recommended Mitigation Steps
Use flag FLAG_ALLOW_FALLBACK_DST
```
function _performCall(bytes memory _calldata) internal virtual {
    //Sends message to AnycallProxy
    IAnycallProxy(localAnyCallAddress).anyCall(
        rootBridgeAgentAddress, _calldata, rootChainId, AnycallFlags.FLAG_ALLOW_FALLBACK_DST, ""
    );
}
```


## [M-01]  Missing deadline checks allow pending transactions to be maliciously executed

## Vulnerability details
### Impact
Without a deadline parameter, the transaction may sit in the mempool and be executed at a much later time potentially resulting in a worse price for the user.


### Proof of Concept
AMMs should provide their users with an option to limit the execution of their pending actions, such as swaps or adding and removing liquidity. The most common solution is to include a deadline timestamp as a parameter (for example see [Uniswap V2](https://github.com/Uniswap/v2-periphery/blob/0335e8f7e1bd1e8d8329fd300aea2ef2f36dd19f/contracts/UniswapV2Router02.sol#L229)).
The affected functions in UlyssesRouter.sol are:

- addLiquidity()
- removeLiquidity()
- swap()

## Recommended Mitigation Steps
Introduce a deadline parameter to the mentioned functions.


## [M-02]  User will permanently lose their assets if someone calls retryDeposit(Settlement) when redeemDeposit(Settlement) should be called

## Vulnerability details
### Impact
When a remote call with deposit(settlement) fails at bridge agent while it is not force reverted, anyFallback will be triggered to set the deposit(settlement) status to Failed. Then, the user should call redeemDeposit(Settlement) to get their assets back. However, if someone calls retryDeposit(Settlement), the status will be set to Success. The remote call will _forceRevert() and anyFallback will not be triggered again, which means the assets will be permanently lost.
```
function anyExecute(bytes calldata data)
    external
    virtual
    requiresExecutor
    returns (bool success, bytes memory result)
{
......
    if (executionHistory[fromChainId][nonce]) {
            _forceRevert();
            //Return true to avoid triggering anyFallback in case of `_forceRevert()` failure
            return (true, "already executed tx");
        }
......
}
```
### Proof of Concept
https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/BranchBridgeAgent.sol#L408

```
function redeemDeposit(uint32 _depositNonce) external lock {
    if (getDeposit[_depositNonce].status != DepositStatus.Failed) {
        revert DepositRedeemUnavailable();
    }
    _redeemDeposit(_depositNonce);
}

function retryDeposit(
    bool _isSigned,
    uint32 _depositNonce,
    bytes calldata _params,
    uint128 _remoteExecutionGas,
    uint24 _toChain
) external payable lock requiresFallbackGas {
    if (getDeposit[_depositNonce].owner != msg.sender) revert NotDepositOwner();
    ......
    getDeposit[_depositNonce].status = DepositStatus.Success;
    _performCall(packedData);
}
```
Thanks to the owner check, this situation can only occur as a result of user mistake when depositing.
```
function redeemSettlement(uint32 _depositNonce) external lock {
    address depositOwner = getSettlement[_depositNonce].owner;

    if (getSettlement[_depositNonce].status != SettlementStatus.Failed || depositOwner == address(0)) {
        revert SettlementRedeemUnavailable();
    } else if (
        msg.sender != depositOwner && msg.sender != address(IPort(localPortAddress).getUserAccount(depositOwner))
    ) {
        revert NotSettlementOwner();
    }
    _redeemSettlement(_depositNonce);
}

function _retrySettlement(uint32 _settlementNonce) internal returns (bool) {
    Settlement memory settlement = getSettlement[_settlementNonce];
    if (settlement.owner == address(0)) return false;

    bytes memory newGas = abi.encodePacked(_manageGasOut(settlement.toChain));
    for (uint256 i = 0; i < newGas.length;) {
        settlement.callData[settlement.callData.length - 16 + i] = newGas[i];
        unchecked {
            ++i;
        }
    }

    Settlement storage settlementReference = getSettlement[_settlementNonce];
    settlementReference.gasToBridgeOut = userFeeInfo.gasToBridgeOut;
    settlementReference.callData = settlement.callData;
    settlementReference.status = SettlementStatus.Success;

    _performCall(settlement.callData, settlement.toChain);
    return true;
}
```
However, when it comes to settlement, there is no owner check in retrySettlement. As a result, any malicious user can call retrySettlement to freeze the assets of innocent users whenever they detect a failed settlement.
## Recommended Mitigation Steps
However, when it comes to settlement, there is no owner check in retrySettlement. As a result, any malicious user can call retrySettlement to freeze the assets of innocent users whenever they detect a failed settlement.
```
require(getDeposit[_depositNonce].status != DepositStatus.Failed);
```

## [M-03]  depositGasAnycallConfig will fail due to unnecessary wrappedNativeToken.withdraw

## Vulnerability details
### Impact
depositGasAnycallConfig will fail because an extra wrappedNativeToken.withdraw is made.
### Proof of Concept
https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/RootBridgeAgent.sol#L1219-L1222
https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/RootBridgeAgent.sol#L848-L852
```
function depositGasAnycallConfig() external payable {
    _replenishGas(msg.value);
}

function _replenishGas(uint256 _executionGasSpent) internal {
    wrappedNativeToken.withdraw(_executionGasSpent);
    IAnycallConfig(IAnycallProxy(localAnyCallAddress).config()).deposit{value: _executionGasSpent}(address(this));
}
```
When an EOA calls depositGasAnycallConfig, ether is sent to the contract. However, an unnecessary wrappedNativeToken.withdraw is performed.
## Recommended Mitigation Steps
Move wrappedNativeToken.withdraw(_executionGasSpent); outside _replenishGas to Line 1172
```
function anyExecute(bytes calldata data) {
    ......
    if (initialGas > 0) {
++      wrappedNativeToken.withdraw(_executionGasSpent);
        _payExecutionGas(userFeeInfo.depositedGas, userFeeInfo.gasToBridgeOut, _initialGas, fromChainId);
    }
}
```


## [M-04]  Incorrect parameter used for _unstakeToken() in function "restakeToken" 

## Vulnerability details
### Impact
Incorrect parameter is used for _unstakeToken() in function "restakeToken". This mistake prevents users from restaking other users' token after incentive ends.
### Proof of Concept
https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/uni-v3-staker/UniswapV3Staker.sol#L342
```
function restakeToken(uint256 tokenId) external {
    IncentiveKey storage incentiveId = stakedIncentiveKey[tokenId];
    if (incentiveId.startTime != 0) _unstakeToken(incentiveId, tokenId, true);
    ......
}
```
The third parameter of _unstakeToken is set to true. However, based on the context in the "restakeToken" function, it should be false to enable anyone to call restakeToken if the block time is after the end time of incentive.
```
The third parameter of _unstakeToken is set to true. However, based on the context in the "restakeToken" function, it should be false to enable anyone to call restakeToken if the block time is after the end time of incentive.
```
## Recommended Mitigation Steps
Set the third parameter to false.
```
if (incentiveId.startTime != 0) _unstakeToken(incentiveId, tokenId, false);
```

## [M-05]  User can "callOutSigned" without paying for gas by reentering "anyExecute" with virtual account 

## Vulnerability details
### Impact
Virtual account can perform external calls during root chain execution process. If it callOut at Arbitrum Branch Bridge Agent, anyExecute in Root Bridge Agent will be reentered. lock will not work if user initiated the process on another branch chain. _payExecutionGas will not charge gas for the reentrancy call, Meanwhile, storage variable initialGas and userFeeInfo will be deleted. As a result, no gas will be charged for the original call.
### Proof of Concept
https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/RootBridgeAgent.sol#L798-L805
```
function anyExecute(bytes calldata data)
    external
    virtual
    requiresExecutor
    returns (bool success, bytes memory result)
{
    uint256 _initialGas = gasleft();
    uint24 fromChainId;
    UserFeeInfo memory _userFeeInfo;

    if (localAnyCallExecutorAddress == msg.sender) {
        initialGas = _initialGas;
        (, uint256 _fromChainId) = _getContext();
        fromChainId = _fromChainId.toUint24();

        _userFeeInfo.depositedGas = _gasSwapIn(
            uint256(uint128(bytes16(data[data.length - PARAMS_GAS_IN:data.length - PARAMS_GAS_OUT]))), fromChainId).toUint128();
        _userFeeInfo.gasToBridgeOut = uint128(bytes16(data[data.length - PARAMS_GAS_OUT:data.length]));
    } else {
        fromChainId = localChainId;
        _userFeeInfo.depositedGas = uint128(bytes16(data[data.length - 32:data.length - 16]));
        _userFeeInfo.gasToBridgeOut = _userFeeInfo.depositedGas;
    }

    if (_userFeeInfo.depositedGas < _userFeeInfo.gasToBridgeOut) {
        _forceRevert();
        return (true, "Not enough gas to bridge out");
    }

    userFeeInfo = _userFeeInfo;

    // execution part
    ............

    if (initialGas > 0) {
        _payExecutionGas(userFeeInfo.depositedGas, userFeeInfo.gasToBridgeOut, _initialGas, fromChainId);
    }
}
```
```
function _payExecutionGas(uint128 _depositedGas, uint128 _gasToBridgeOut, uint256 _initialGas, uint24 _fromChain) internal {
    delete(initialGas);
    delete(userFeeInfo);

    if (_fromChain == localChainId) return;

    uint256 availableGas = _depositedGas - _gasToBridgeOut;
    uint256 minExecCost = tx.gasprice * (MIN_EXECUTION_OVERHEAD + _initialGas - gasleft());
    if (minExecCost > availableGas) {
        _forceRevert();
        return;
    }

    _replenishGas(minExecCost);

    accumulatedFees += availableGas - minExecCost;
}
```
During the reentrancy call, initialGas will not be modified before the execution part; _payExecutionGas will be invoked, but it will directly return after deleting initialGas and userFeeInfo. As a result, after the execution part of original call, _payExecutionGas will be passed as initialGas is now zero.

## Recommended Mitigation Steps
Store initialGas and userFeeInfo in memory as local variable inside anyExecute.


## [M-06]  Incorrect accounting logic for fallback gas will lead to insolvency

## Vulnerability details
### Impact
Incorrect accounting logic for fallback gas will lead to insolvency.
### Proof of Concept
https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/RootBridgeAgent.sol#L823
https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/BranchBridgeAgent.sol#L1044
```
// on root chain
function _payExecutionGas(uint128 _depositedGas, uint128 _gasToBridgeOut, uint256 _initialGas, uint24 _fromChain) internal {
    ......
    uint256 availableGas = _depositedGas - _gasToBridgeOut;
    uint256 minExecCost = tx.gasprice * (MIN_EXECUTION_OVERHEAD + _initialGas - gasleft());

    if (minExecCost > availableGas) {
        _forceRevert();
        return;
    }

    _replenishGas(minExecCost);

    //Account for excess gas
    accumulatedFees += availableGas - minExecCost;
}

// on branch chain
function _payFallbackGas(uint32 _depositNonce, uint256 _initialGas) internal virtual {
    ......
    IPort(localPortAddress).withdraw(address(this), address(wrappedNativeToken), minExecCost);
    wrappedNativeToken.withdraw(minExecCost);
    _replenishGas(minExecCost);
}
```
As above, when paying execution gas on the root chain, the excessive gas is added to accumulatedFees. So theoretically all deposited gas is used up and no gas has been reserved for anyFallback on the branch chain. The withdrawl in _payFallbackGas on branch chain will cause insolvency.

```
// on branch chain
function _payExecutionGas(address _recipient, uint256 _initialGas) internal virtual {
    ......
    uint256 gasLeft = gasleft();
    uint256 minExecCost = tx.gasprice * (MIN_EXECUTION_OVERHEAD + _initialGas - gasLeft);

    if (minExecCost > gasRemaining) {
        _forceRevert();
        return;
    }

    _replenishGas(minExecCost);

    //Transfer gas remaining to recipient
    SafeTransferLib.safeTransferETH(_recipient, gasRemaining - minExecCost);
    ......
    }
}

// on root chain
function _payFallbackGas(uint32 _settlementNonce, uint256 _initialGas) internal virtual {
    uint256 gasLeft = gasleft();
    uint256 minExecCost = tx.gasprice * (MIN_FALLBACK_RESERVE + _initialGas - gasLeft);

    if (minExecCost > getSettlement[_settlementNonce].gasToBridgeOut) {
        _forceRevert();
        return;
    }

    getSettlement[_settlementNonce].gasToBridgeOut -= minExecCost.toUint128();
}
```

As above, when paying execution gas on the branch chain, the excessive gas has be sent to the recipent. So therotically all deposited gas is used up and no gas has been reserved for anyFallback on the root chain. _payFallbackGas does not _replenishGas, which will cause insolvency of gas budget in AnycallConfig.

## Recommended Mitigation Steps
Deduct fallback gas from deposited gas.